# MultiQuark

- **Author**: Simon Lavoie

- **Contact**: simon.lavoie@mail.mcgill.ca

My program for summer 2024 internship analyzing ATLAS data for the search of multiquark states.

# Project Structure 

The multiquark analysis software is divided up into two parts. One is a private 
repo hosted on GitLab, which requires CERN credentials to access,
and can be found [here](https://gitlab.cern.ch/slavoie/MyAnalysis). The second
part is hosted on my public GitHub account and can be found
[here](https://github.com/simlav000/Multiquark) (you're probably here).

It is recommended you read this documentation on the GitLab/GitLab as both platforms 
provide a markdown format viewer.

# GitHub Repo
This repo contains functions and tools to make complete plots of the 
intermediate data generated by the analysis script hosted on the GitLab. 
It utilizes a hierarchical class structure make make the plotting functions 
more general.

## Class Structure
The `Particle.h` file defines a base (virtual) `Particle` class. This is a 
data class complete with fields designating default values for the class, 
such as the particle's PDG (Particle Data Group) mass, LaTeX-formatted name,
etc. The subsequent `Kaon` and `Lambda` classes inherit directly from the 
`Particle`class and implement these fields. Thus, functions which plot 
things related to secondary vertices take a `Particle` as input, and read 
the default `Kaon` or `Lambda` fields to know how to plot the histogram.

The `Multiquark` class is another (virtual) class which inherits `Particle`,
and is defined as having all the fields of a `Particle` (though it does not 
make use of them all - e.g. mass), plus a few more 
which are necessary for plotting the multiquark invariant mass distributions.
The `Tetraquark`, `Pentaquark` and `Hexaquark` classes all inherit from 
`Multiquark` and implement the fields.

Each of the `Kaon`, `Lambda`, and all three `Multiquark` inheritors are 
implemented as a singleton pattern. This basically means only one instance
of these classes can be instantiated, and they are retrieved using the 
`GetInstance()` methods provided. The instances are retrieved
once in the main method.
I did this since I cannot imagine a scenario where two such objects would 
need to exist, given each object is basically implemented to be a lookup table
of constant and unchanging (during the runtime) values.

## Headers
There are a few more headers in this repo. Let's go through them.

1. `Cuts.h`: This file contains `inline` definitions of cuts used by 
`MakeHists.cxx`. These cuts are a series of `TCut` objects which act as 
masks on the data and are passed as arguments when creating the histogram 
objects. The bottom of this file contains the `SetCutNames()` function 
which is called within `MakeHists.cxx`'s main method and defines a 
description of the cut which is automatically input to the histogram 
legend in a few of the plotting functions.
2. `Fits.h`: This file contains various fit models used throughout the 
plotting functions. 
3. `Utilities.h`: This contains a few quality of life functions I used to 
make the histograms, like converting a float value to a string with a defined 
precision, etc.

## MakeHists.cxx
This is the main macro used to make the final analysis histograms. It is a 
ROOT macro, meaning it is executed by running `root MakeHists.cxx`. It 
currently runs on ROOT version 6.30/04. There are a number of `#include` 
statements for ROOT headers. I believe these are not necessary if the macro
is to be executed using the `root` command, but having these makes the program
flexible as it can be compiled and executed as a program. 

The main method of this file, being a function of the same name, searches for 
the data files as specified by strings you must modify to locate the 
intermediate n-tuples from the analysis code. After a bit of error handling, 
you may call any of the functions defined within the file. Each function 
should have a docstring explaining what it does and what it needs to run 
properly. 

